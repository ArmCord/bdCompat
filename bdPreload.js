(() => { "use strict"; var e = { n: r => { var n = r && r.__esModule ? () => r.default : () => r; return e.d(n, { a: n }), n }, d: (r, n) => { for (var t in n) e.o(n, t) && !e.o(r, t) && Object.defineProperty(r, t, { enumerable: !0, get: n[t] }) }, o: (e, r) => Object.prototype.hasOwnProperty.call(e, r), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; e.r(r), e.d(r, { createDirectory: () => y, createWriteStream: () => k, deleteDirectory: () => b, exists: () => m, getRealPath: () => h, getStats: () => _, readDirectory: () => g, readFile: () => p, rename: () => S, renameSync: () => w, rm: () => R, rmSync: () => v, unlinkSync: () => L, watch: () => O, writeFile: () => f }); var n = {}; e.r(n), e.d(n, { ipcRenderer: () => A, shell: () => i.shell }); var t = {}; e.r(t), e.d(t, { createHash: () => x, randomBytes: () => E }); var o = {}; e.r(o), e.d(o, { compileFunction: () => H }); var c = {}; e.r(c), e.d(c, { crypto: () => t, electron: () => n, filesystem: () => r, https: () => T, net: () => W, os: () => I, path: () => U, vm: () => o }); const i = require("electron"); function s(e) { const r = []; for (const n in e) r.push(n); return r } function a(e, r = {}, n) { return Array.isArray(n) || (n = s(e)), n.reduce(((r, n) => ("object" != typeof e[n] || Array.isArray(e[n]) || null === e[n] ? "function" == typeof e[n] ? r[n] = e[n].bind(e) : r[n] = e[n] : r[n] = a(e[n], {}), r)), r) } const d = a(process, {}, s(process).filter((e => "config" !== e))), u = require("fs"), l = { err: "error", error: "error", dbg: "debug", debug: "debug", log: "log", warn: "warn", info: "info" }; class Logger { static stacktrace(e, r, n) { console.error(`%c[${e}]%c ${r}\n\n%c`, "color: #3a71c1; font-weight: 700;", "color: red; font-weight: 700;", "color: red;", n) } static err(e, ...r) { Logger._log(e, r, "error") } static error(e, ...r) { Logger._log(e, r, "error") } static warn(e, ...r) { Logger._log(e, r, "warn") } static info(e, ...r) { Logger._log(e, r, "info") } static debug(e, ...r) { Logger._log(e, r, "debug") } static log(e, ...r) { Logger._log(e, r) } static _log(e, r, n = "log") { n = Logger.parseType(n), Array.isArray(r) || (r = [r]), console[n](`%c[BetterDiscord]%c [${e}]%c`, "color: #3E82E5; font-weight: 700;", "color: #3a71c1;", "", ...r) } static parseType(e) { return l[e] || "log" } } function p(e, r = "utf8") { return u.readFileSync(e, r) } function f(e, r, n) { r instanceof Uint8Array && (r = Buffer.from(r)); return (n?.originalFs ? require("original-fs").writeFileSync : u.writeFileSync)(e, r, n) } function g(e, r) { return u.readdirSync(e, r) } function y(e, r) { return u.mkdirSync(e, r) } function b(e, r) { u.rmdirSync(e, r) } function m(e) { return u.existsSync(e) } function h(e, r) { return u.realpathSync(e, r) } function S(e, r) { return u.renameSync(e, r) } function w(e, r) { return u.renameSync(e, r) } function R(e) { return u.rmSync(e) } function v(e) { return u.rmSync(e) } function L(e) { return u.unlinkSync(e) } function k(e, r) { return a(u.createWriteStream(e, r)) } function O(e, r, n) { const t = u.watch(e, r, ((e, r) => { try { n(e, r) } catch (e) { Logger.stacktrace("filesystem", "Failed to watch path", e) } })); return { close: () => { t.close() } } } function _(e, r) { const n = u.statSync(e, r); return { ...n, isFile: n.isFile.bind(n), isDirectory: n.isDirectory.bind(n), isSymbolicLink: n.isSymbolicLink.bind(n) } } const j = require("https"), q = new Set([301, 302, 307, 308]), F = ["statusCode", "statusMessage", "url", "headers", "method", "aborted", "complete", "rawHeaders", "end"], P = (e, r, n, t) => { const o = j.request(e, Object.assign({ method: "GET" }, r), (c => { if (q.has(c.statusCode) && c.headers.location) { const o = new URL(c.headers.location); for (const [r, n] of new URL(e).searchParams.entries()) o.searchParams.set(r, n); return P(o.toString(), r, n, t) } const i = []; let s = null; t(c, o), c.addListener("error", (e => { s = e })), c.addListener("data", (e => { i.push(e) })), c.addListener("end", (() => { const e = Object.fromEntries(F.map((e => [e, c[e]]))); n(s, e, Buffer.concat(i)), o.end() })) })); o.end() }, D = function (e, r, n) { let t = null, o = null, c = null; return P(e, r, n, ((e, r) => { o = e, t = r, c && r.pipe(c) })), { end() { o?.end() }, pipe(e) { t ? t.pipe(e) : c = e } } }, T = Object.assign({ request: D }, Object.fromEntries(["get", "put", "post", "delete"].map((e => [e, function () { return arguments[1] ??= {}, arguments[1].method ??= e.toUpperCase(), Reflect.apply(D, this, arguments) }])))), A = { send: i.ipcRenderer.send.bind(i.ipcRenderer), sendToHost: i.ipcRenderer.sendToHost.bind(i.ipcRenderer), sendTo: i.ipcRenderer.sendTo.bind(i.ipcRenderer), sendSync: i.ipcRenderer.sendSync.bind(i.ipcRenderer), invoke: i.ipcRenderer.invoke.bind(i.ipcRenderer), on: i.ipcRenderer.on.bind(i.ipcRenderer), off: i.ipcRenderer.off.bind(i.ipcRenderer) }, B = (() => { let e = null; return () => e || (e = require("crypto")) })(); function x(e) { const r = B().createHash(e), n = { update: e => (r.update(e), n), digest: e => r.digest(e) }; return n } function E(e) { return B().randomBytes(e) } const M = require("vm"); var C = e.n(M); function H(e, r = [], n = {}) { try { return C().compileFunction(e, r, n) } catch (e) { return { name: e.name, message: e.message, stack: e.stack } } } const U = require("path"), W = require("net"), I = require("os"); i.webFrame.top.executeJavaScript("(" + function () { const e = "webpackChunkdiscord_app", r = function (e, r, n) { const t = e[r]; Object.defineProperty(e, r, { get: () => t, set(t) { Object.defineProperty(e, r, { value: t, configurable: !0, enumerable: !0, writable: !0 }); try { n(t) } catch (e) { console.error(e) } return t }, configurable: !0 }) }; Reflect.has(window, e) || r(window, e, (e => { r(e, "push", (() => { e.push([[Symbol()], {}, e => { e.d = (e, r) => { for (const n in r) Reflect.has(r, n) && !e[n] && Object.defineProperty(e, n, { get: () => r[n](), set: e => { r[n] = () => e }, enumerable: !0, configurable: !0 }) } }]), e.pop() })) })) } + ")()"); let $ = !1; i.contextBridge.exposeInMainWorld("process", d), i.contextBridge.exposeInMainWorld("BetterDiscordPreload", (() => $ ? null : ($ = !0, c))), function () { const e = process.env.DISCORD_PRELOAD; if (e) { i.ipcRenderer.send("bd-register-preload", e); try { const r = process.kill; process.kill = function () { }, require(e), process.kill = r } catch (e) { } } }() })();